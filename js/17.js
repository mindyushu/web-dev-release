(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[17],{

/***/ "./src/viewmodel/core/base/LinePath.js":
/*!*********************************************!*\
  !*** ./src/viewmodel/core/base/LinePath.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _Point = _interopRequireDefault(__webpack_require__(/*! ./Point */ \"./src/viewmodel/core/base/Point.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar LinePath = /*#__PURE__*/function () {\n  function LinePath() {\n    _classCallCheck(this, LinePath);\n    this.line = \"\";\n    this.effectRadius = 0;\n    this.lineToList = [];\n    this.isEffectRadius = true;\n  }\n  _createClass(LinePath, [{\n    key: \"setEffectRadius\",\n    value: function setEffectRadius(radius) {\n      if (radius >= 0) {\n        this.effectRadius = radius;\n      }\n    }\n  }, {\n    key: \"moveToByPoint\",\n    value: function moveToByPoint(point) {\n      this.moveTo(point.x, point.y);\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(x, y) {\n      this.addLine(\"M\" + x + \",\" + y);\n      this.lineToList = [];\n      this.lineToList.push(new _Point.default(x, y));\n    }\n  }, {\n    key: \"move\",\n    value: function move(point) {\n      if (point != null && point.x != null) {\n        this.moveTo(point.x, point.y);\n      }\n    }\n  }, {\n    key: \"lineTo\",\n    value: function lineTo(x, y) {\n      this.addLine(\"L\" + x + \" \" + y);\n      this.lineToList.push(new _Point.default(x, y));\n    }\n  }, {\n    key: \"lineToByPoint\",\n    value: function lineToByPoint(point) {\n      this.lineTo(point.x, point.y);\n    }\n  }, {\n    key: \"circle\",\n    value: function circle(radius1, radius2) {\n      var xAxisRotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var largeArcFlag = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      var sweepFlag = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n      var x = arguments.length > 5 ? arguments[5] : undefined;\n      var y = arguments.length > 6 ? arguments[6] : undefined;\n      //第一个为水平半径，第二个为垂直半径。第三个为旋转角度。第四个为大圆小圆。第五个为顺时针逆时针。 最后两个个为终点坐标\n      // 20 20 0 1 1 100 100\n      this.addLine(\"A\" + ' ' + radius1 + ' ' + radius2 + ' ' + xAxisRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + x + ' ' + y);\n    }\n  }, {\n    key: \"cubicTo\",\n    value: function cubicTo(c1x, c1y, c2x, c2y, endx, endy) {\n      this.addLine(\"C\" + c1x + \" \" + c1y + \",\" + c2x + \" \" + c2y + \",\" + endx + \" \" + endy);\n      this.isEffectRadius = false;\n    }\n  }, {\n    key: \"cubicToByIos\",\n    value: function cubicToByIos(endx, endy, c1x, c1y, c2x, c2y) {\n      this.cubicTo(c1x, c1y, c2x, c2y, endx, endy);\n    }\n  }, {\n    key: \"addQuadCurve\",\n    value: function addQuadCurve(toPoint, controlPoint) {\n      this.cubicOneTo(controlPoint.x, controlPoint.y, toPoint.x, toPoint.y);\n    }\n  }, {\n    key: \"cubicOneTo\",\n    value: function cubicOneTo(c1x, c1y, endx, endy) {\n      this.addLine(\"Q\" + c1x + \" \" + c1y + \",\" + endx + \" \" + endy);\n      this.isEffectRadius = false;\n    }\n  }, {\n    key: \"getLine\",\n    value: function getLine() {\n      if (!this.isEffectRadius || this.lineToList.length == 0 || this.effectRadius <= 0) {\n        return this.line;\n      } else {\n        var length = this.lineToList.length;\n        var effectLine = \"\";\n        for (var index = 0; index < length; index++) {\n          var point = this.lineToList[index];\n          if (index == 0) {\n            effectLine = \"M\" + point.x + \" \" + point.y;\n          } else if (index < length - 1) {\n            var previousPoint = this.lineToList[index - 1];\n            var nextPoint = this.lineToList[index + 1];\n            var sweep = 0;\n            if (point.x > previousPoint.x) {\n              //向右画线\n\n              if (point.x == nextPoint.x) {\n                //垂直转角\n                var max = Math.abs(point.y - nextPoint.y);\n                var smallRadius = this.effectRadius;\n                if (max / 2 < smallRadius) {\n                  smallRadius = max / 2;\n                }\n                if (point.y > nextPoint.y) {\n                  //向上转角\n                  sweep = 0;\n                  effectLine += \"L\" + (point.x - smallRadius) + \" \" + point.y;\n                  effectLine += \"A\" + smallRadius + \",\" + smallRadius + \" 0 0, \" + sweep + \" \" + point.x + \" \" + (point.y - smallRadius);\n                } else if (point.y < nextPoint.y) {\n                  //向下转角\n                  sweep = 1;\n                  effectLine += \"L\" + (point.x - smallRadius) + \" \" + point.y;\n                  effectLine += \"A\" + smallRadius + \",\" + smallRadius + \" 0 0, \" + sweep + \" \" + point.x + \" \" + (point.y + smallRadius);\n                }\n              } else {\n                effectLine += \"L\" + point.x + \" \" + point.y;\n              }\n            } else if (point.x == previousPoint.x) {\n              // 垂直画线\n              // effectLine += \"L\" + (point.x) + \" \" + point.y\n              if (point.y == nextPoint.y) {\n                //垂直转角\n                var _max = Math.abs(point.y - previousPoint.y); //当前坐标和上一个坐标的y轴差值\n                var _smallRadius = this.effectRadius;\n                if (_max / 2 < _smallRadius) {\n                  _smallRadius = _max / 2;\n                }\n                if (point.y < previousPoint.y) {\n                  //向上\n                  if (point.x > nextPoint.x) {\n                    //向左\n                    sweep = 0;\n                    effectLine += \"L\" + point.x + \" \" + (point.y + _smallRadius);\n                    effectLine += \"A\" + _smallRadius + \",\" + _smallRadius + \" 0 0, \" + sweep + \" \" + (point.x - _smallRadius) + \" \" + point.y;\n                  } else if (point.x < nextPoint.x) {\n                    //向右转角\n                    sweep = 1;\n                    effectLine += \"L\" + point.x + \" \" + (point.y + _smallRadius);\n                    effectLine += \"A\" + _smallRadius + \",\" + _smallRadius + \" 0 0, \" + sweep + \" \" + (point.x + _smallRadius) + \" \" + point.y;\n                  }\n                } else if (point.y > previousPoint.y) {\n                  //向下\n                  if (point.x > nextPoint.x) {\n                    //向左\n                    sweep = 1;\n                    effectLine += \"L\" + point.x + \" \" + (point.y - _smallRadius);\n                    effectLine += \"A\" + _smallRadius + \",\" + _smallRadius + \" 0 0, \" + sweep + \" \" + (point.x - _smallRadius) + \" \" + point.y;\n                  } else if (point.x < nextPoint.x) {\n                    //向右转角\n                    sweep = 0;\n                    effectLine += \"L\" + point.x + \" \" + (point.y - _smallRadius);\n                    effectLine += \"A\" + _smallRadius + \",\" + _smallRadius + \" 0 0, \" + sweep + \" \" + (point.x + _smallRadius) + \" \" + point.y;\n                  }\n                }\n              } else {\n                effectLine += \"L\" + point.x + \" \" + point.y;\n              }\n            } else {\n              //向左画线\n              if (point.x == nextPoint.x) {\n                //垂直转角\n                var _max2 = Math.abs(point.y - nextPoint.y);\n                var _smallRadius2 = this.effectRadius;\n                if (_max2 / 2 < _smallRadius2) {\n                  _smallRadius2 = _max2 / 2;\n                }\n                if (point.y > nextPoint.y) {\n                  //向上转角\n                  sweep = 1;\n                  effectLine += \"L\" + (point.x + _smallRadius2) + \" \" + point.y;\n                  effectLine += \"A\" + _smallRadius2 + \",\" + _smallRadius2 + \" 0 0, \" + sweep + \" \" + point.x + \" \" + (point.y - _smallRadius2);\n                } else if (point.y < nextPoint.y) {\n                  //向下转角\n                  sweep = 0;\n                  effectLine += \"L\" + (point.x + _smallRadius2) + \" \" + point.y;\n                  effectLine += \"A\" + _smallRadius2 + \",\" + _smallRadius2 + \" 0 0, \" + sweep + \" \" + point.x + \" \" + (point.y + _smallRadius2);\n                }\n              } else {\n                effectLine += \"L\" + point.x + \" \" + point.y;\n              }\n\n              // effectLine += \"L\" + (point.x) + \" \" + point.y\n            }\n          } else {\n            effectLine += \"L\" + point.x + \" \" + point.y;\n          }\n        }\n        return effectLine;\n      }\n    }\n  }, {\n    key: \"getLineRadius\",\n    value: function getLineRadius() {\n      if (!this.isEffectRadius || this.lineToList.length == 0 || this.effectRadius <= 0) {\n        return this.line;\n      } else {\n        var length = this.lineToList.length;\n        var effectLine = \"\";\n        for (var index = 0; index < length; index++) {\n          var point = this.lineToList[index];\n          if (index == 0) {\n            effectLine = \"M\" + point.x + \" \" + point.y;\n          } else if (index < length - 1) {\n            var previousPoint = this.lineToList[index - 1];\n            var nextPoint = this.lineToList[index + 1];\n            if (point.x == previousPoint.x && point.y == previousPoint.y) {\n              effectLine += \"L\" + point.x + \" \" + point.y;\n              continue;\n            }\n            var sweep = 0;\n            if (point.x > previousPoint.x) {\n              //向右画线\n\n              if (point.x == nextPoint.x) {\n                //垂直转角\n                var max = Math.abs(point.y - nextPoint.y);\n                var smallRadius = this.effectRadius;\n                if (max / 2 < smallRadius) {\n                  smallRadius = max / 2;\n                }\n                if (point.y > nextPoint.y) {\n                  //向上转角\n                  sweep = 0;\n                  effectLine += \"L\" + (point.x - smallRadius) + \" \" + point.y;\n                  effectLine += \"A\" + smallRadius + \",\" + smallRadius + \" 0 0, \" + sweep + \" \" + point.x + \" \" + (point.y - smallRadius);\n                } else if (point.y < nextPoint.y) {\n                  //向下转角\n                  sweep = 1;\n                  effectLine += \"L\" + (point.x - smallRadius) + \" \" + point.y;\n                  effectLine += \"A\" + smallRadius + \",\" + smallRadius + \" 0 0, \" + sweep + \" \" + point.x + \" \" + (point.y + smallRadius);\n                }\n              } else {\n                effectLine += \"L\" + point.x + \" \" + point.y;\n              }\n            } else if (point.x == previousPoint.x) {\n              // 垂直画线\n              // effectLine += \"L\" + (point.x) + \" \" + point.y\n              if (point.y == nextPoint.y) {\n                //垂直转角\n                var _max3 = Math.abs(point.y - previousPoint.y); //当前坐标和上一个坐标的y轴差值\n                var _smallRadius3 = this.effectRadius;\n                if (_max3 / 2 < _smallRadius3) {\n                  _smallRadius3 = _max3 / 2;\n                }\n                if (point.y < previousPoint.y) {\n                  //向上\n                  if (point.x > nextPoint.x) {\n                    //向左\n                    sweep = 0;\n                    effectLine += \"L\" + point.x + \" \" + (point.y + _smallRadius3);\n                    effectLine += \"A\" + _smallRadius3 + \",\" + _smallRadius3 + \" 0 0, \" + sweep + \" \" + (point.x - _smallRadius3) + \" \" + point.y;\n                  } else if (point.x < nextPoint.x) {\n                    //向右转角\n                    sweep = 1;\n                    effectLine += \"L\" + point.x + \" \" + (point.y + _smallRadius3);\n                    effectLine += \"A\" + _smallRadius3 + \",\" + _smallRadius3 + \" 0 0, \" + sweep + \" \" + (point.x + _smallRadius3) + \" \" + point.y;\n                  }\n                } else if (point.y > previousPoint.y) {\n                  //向下\n                  if (point.x > nextPoint.x) {\n                    //向左\n                    sweep = 1;\n                    effectLine += \"L\" + point.x + \" \" + (point.y - _smallRadius3);\n                    effectLine += \"A\" + _smallRadius3 + \",\" + _smallRadius3 + \" 0 0, \" + sweep + \" \" + (point.x - _smallRadius3) + \" \" + point.y;\n                  } else if (point.x < nextPoint.x) {\n                    //向右转角\n                    sweep = 0;\n                    effectLine += \"L\" + point.x + \" \" + (point.y - _smallRadius3);\n                    effectLine += \"A\" + _smallRadius3 + \",\" + _smallRadius3 + \" 0 0, \" + sweep + \" \" + (point.x + _smallRadius3) + \" \" + point.y;\n                  }\n                }\n              } else {\n                effectLine += \"L\" + point.x + \" \" + point.y;\n              }\n            } else {\n              //向左画线\n              if (point.x == nextPoint.x) {\n                //垂直转角\n                var _max4 = Math.abs(point.y - nextPoint.y);\n                var _smallRadius4 = this.effectRadius;\n                if (_max4 / 2 < _smallRadius4) {\n                  _smallRadius4 = _max4 / 2;\n                }\n                if (point.y > nextPoint.y) {\n                  //向上转角\n                  sweep = 1;\n                  effectLine += \"L\" + (point.x + _smallRadius4) + \" \" + point.y;\n                  effectLine += \"A\" + _smallRadius4 + \",\" + _smallRadius4 + \" 0 0, \" + sweep + \" \" + point.x + \" \" + (point.y - _smallRadius4);\n                } else if (point.y < nextPoint.y) {\n                  //向下转角\n                  sweep = 0;\n                  effectLine += \"L\" + (point.x + _smallRadius4) + \" \" + point.y;\n                  effectLine += \"A\" + _smallRadius4 + \",\" + _smallRadius4 + \" 0 0, \" + sweep + \" \" + point.x + \" \" + (point.y + _smallRadius4);\n                }\n              } else {\n                effectLine += \"L\" + point.x + \" \" + point.y;\n              }\n            }\n          } else {\n            effectLine += \"L\" + point.x + \" \" + point.y;\n          }\n        }\n        return effectLine;\n      }\n    }\n  }, {\n    key: \"addLine\",\n    value: function addLine(path) {\n      if (this.checkStr(this.line)) {\n        this.line += \"\" + path; //\", \" + path\n      } else {\n        this.line = path;\n      }\n    }\n  }, {\n    key: \"checkStr\",\n    value: function checkStr(str) {\n      return this.line != null && this.line.length > 0;\n    }\n  }]);\n  return LinePath;\n}();\nvar _default = exports.default = LinePath;\n\n//# sourceURL=webpack:///./src/viewmodel/core/base/LinePath.js?");

/***/ }),

/***/ "./src/views/book/data/BookData.js":
/*!*****************************************!*\
  !*** ./src/views/book/data/BookData.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _Colors = _interopRequireDefault(__webpack_require__(/*! ../../../utils/Colors */ \"./src/utils/Colors.js\"));\nvar _Strings = _interopRequireDefault(__webpack_require__(/*! ../../../utils/Strings */ \"./src/utils/Strings.js\"));\nvar _UiUtil = _interopRequireDefault(__webpack_require__(/*! ../../../utils/UiUtil */ \"./src/utils/UiUtil.js\"));\nvar _Util = _interopRequireDefault(__webpack_require__(/*! ../../../utils/Util */ \"./src/utils/Util.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); } // package mind.yushu.com.mindmap.main.book.data;\n// import mind.yushu.com.mindmap.utils.Colors;\n// import mind.yushu.com.mindmap.utils.Strings;\n// import mind.yushu.com.mindmap.utils.UiUtil;\n// import mind.yushu.com.mindmap.utils.Util;\n// import mind.yushu.com.mindmap.viewmodel.datatype.MindHistoryCellType;\n/**\n * ProjectName: MindMap\n * Created by tony on 6/23/21\n * Copyright(c) 2020 mindyushu.com\n */\nvar BookData = /*#__PURE__*/function () {\n  function BookData() {\n    _classCallCheck(this, BookData);\n    // this.UiUtil = new UiUtil();\n    // this.width = this.UiUtil.dip2px(95);\n    // this.height = this.UiUtil.dip2px(117);\n    // this.color = Colors.red;\n    // this.url = \"\";\n    // this.sheetNumber = 2;\n    // this.name = \"超级记忆术\";\n    // this.subtitle = \"超级记忆术，脑开发\";\n    // this.time = Util.getCurrentTime();\n    // this.id = \"\";\n\n    this.UiUtil = new _UiUtil.default();\n    this.width = this.UiUtil.dip2px(95);\n    this.height = this.UiUtil.dip2px(117);\n    this.color = _Colors.default.red;\n    this.url = \"\";\n    this.sheetNumber = 0;\n    this.name = \"\";\n    this.subtitle = \"\";\n    this.time = _Util.default.getCurrentTime();\n    this.id = \"\";\n  }\n  _createClass(BookData, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return new _Strings.default().isEmpty(this.id);\n    }\n  }]);\n  return BookData;\n}();\nvar _default = exports.default = BookData;\n\n//# sourceURL=webpack:///./src/views/book/data/BookData.js?");

/***/ }),

/***/ "./src/views/book/ui/BookView.js":
/*!***************************************!*\
  !*** ./src/views/book/ui/BookView.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _Config = _interopRequireDefault(__webpack_require__(/*! ../../../core/core/calcule/Config */ \"./src/core/core/calcule/Config.js\"));\nvar _MindElementCalculation = _interopRequireDefault(__webpack_require__(/*! ../../../core/core/calcule/elementCalculation/MindElementCalculation */ \"./src/core/core/calcule/elementCalculation/MindElementCalculation.js\"));\nvar _Colors = _interopRequireDefault(__webpack_require__(/*! ../../../utils/Colors */ \"./src/utils/Colors.js\"));\nvar _Strings = _interopRequireDefault(__webpack_require__(/*! ../../../utils/Strings */ \"./src/utils/Strings.js\"));\nvar _timestampToTime = _interopRequireDefault(__webpack_require__(/*! ../../../utils/timestampToTime */ \"./src/utils/timestampToTime.js\"));\nvar _UiUtil = _interopRequireDefault(__webpack_require__(/*! ../../../utils/UiUtil */ \"./src/utils/UiUtil.js\"));\nvar _Util = _interopRequireDefault(__webpack_require__(/*! ../../../utils/Util */ \"./src/utils/Util.js\"));\nvar _CGPoint = _interopRequireDefault(__webpack_require__(/*! ../../../viewmodel/core/base/basedata/CGPoint */ \"./src/viewmodel/core/base/basedata/CGPoint.js\"));\nvar _Rect = _interopRequireDefault(__webpack_require__(/*! ../../../viewmodel/core/base/basedata/Rect */ \"./src/viewmodel/core/base/basedata/Rect.js\"));\nvar _LinePath = _interopRequireDefault(__webpack_require__(/*! ../../../viewmodel/core/base/LinePath */ \"./src/viewmodel/core/base/LinePath.js\"));\nvar _httpImageToPrefix = _interopRequireDefault(__webpack_require__(/*! ../../../utils/httpImageToPrefix */ \"./src/utils/httpImageToPrefix.js\"));\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : String(i); }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); } // package mind.yushu.com.mindmap.main.book.ui;\nvar BookView = /*#__PURE__*/function () {\n  function BookView(context, book) {\n    _classCallCheck(this, BookView);\n    this.UiUtil = new _UiUtil.default();\n    this.Util = _Util.default;\n    this.Strings = new _Strings.default();\n    this.horizontalOffset = 1; //书倾斜度\n    this.thickness = 2; //书厚度\n    this.edgeHieght = this.UiUtil.dip2px(2); //书边缘高度\n    this.corner = this.UiUtil.dip2px(4); //书正面矩形圆角\n    this.margin = this.UiUtil.dip2px(4);\n    this.frontBottomRectTop = 0;\n    // this.titlePaint = new Paint();\n    // this.paint = new Paint();\n    // this.mPaint;\n    this.mXfermode;\n    this.frontLeft = 0;\n    this.bitmap = null;\n    this.frontBottomColors = 0xF7F7F7;\n    this.book;\n    this.context = context; //画布的父元素\n    this.canvasTag; // 画布标签\n    this.gTag; //g标签\n    this.BookView(context, book);\n  }\n  _createClass(BookView, [{\n    key: \"BookView\",\n    value: function BookView(context, book) {\n      // super(context);\n      this.book = book;\n      this.thickness = this.book.height / 19;\n      this.horizontalOffset = this.thickness / 2;\n      this.frontBottomRectTop = this.book.height / 16 * 9;\n      this.frontLeft = this.edgeHieght + this.horizontalOffset / 2 * 3;\n      this.onDraw();\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(book) {\n      this.book = book;\n      this.bitmap = null;\n      // readLoadImage();\n      // invalidate();\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.book;\n    }\n\n    // @Override\n  }, {\n    key: \"onDraw\",\n    value: function onDraw() {\n      var backRect = new _Rect.default(0, 0, this.book.width - this.horizontalOffset, this.book.height);\n      //头部的矩形\n      var frontRect = new _Rect.default(this.frontLeft, this.thickness + this.edgeHieght, this.book.width - this.frontLeft, this.book.height - this.edgeHieght - this.thickness);\n      var interlayerRect = new _Rect.default(this.edgeHieght, this.edgeHieght, this.book.width - this.edgeHieght, this.thickness);\n      //底部波浪矩形\n      var frontBottomRect = new _Rect.default(this.frontLeft, this.frontBottomRectTop, this.book.width - this.frontLeft, this.book.height - this.frontBottomRectTop);\n      var emptyWidth = (this.book.width - this.frontLeft) / 3;\n      var emptyRect = new _Rect.default(this.frontLeft + (this.book.width - this.frontLeft - emptyWidth) / 2, this.thickness + (this.book.height - this.thickness - emptyWidth) / 2, emptyWidth, emptyWidth);\n      this.createdCanvas();\n      if (_Colors.default.getUiColor(this.book.color) == _Colors.default.getUiColor(_Colors.default.white)) {\n        this.drawRect(backRect, \"\", 0, _Colors.default.getNumberToRgbDark(_Colors.default.black35), this.corner);\n        this.drawInterlayer(interlayerRect);\n        this.drawFrontRect(frontRect, \"\", 0, _Colors.default.getUiColor(_Colors.default.black35), this.corner);\n      } else {\n        this.drawRect(backRect, \"\", 0, _Colors.default.getNumberToRgbDark(this.book.color), this.corner);\n        this.drawInterlayer(interlayerRect);\n        this.drawFrontRect(frontRect, \"\", 0, _Colors.default.getUiColor(this.book.color), this.corner);\n      }\n      this.drawFrontBottomRect(frontBottomRect, \"\", 0, _Colors.default.getUiColor(this.frontBottomColors), this.corner);\n\n      //不为空时执行\n      if (!this.book.isEmpty()) {\n        this.drawTitleAndTime(frontRect, frontBottomRect);\n        this.drawSheetNumber();\n        this.drawImage();\n      }\n      this.drawEmptyPlus(emptyRect);\n    }\n  }, {\n    key: \"createdCanvas\",\n    value: function createdCanvas() {\n      //创建canvas和g标签\n      if (this.canvasTag != null) {\n        this.canvasTag.parentNode.removeChild(this.canvasTag);\n        this.canvasTag = null;\n      }\n      this.canvasTag = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n      this.canvasTag.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n      this.canvasTag.style.width = this.book.width + \"px\";\n      this.canvasTag.style.height = this.book.height + \"px\";\n      this.context.appendChild(this.canvasTag);\n      this.gTag = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n      this.canvasTag.appendChild(this.gTag);\n    }\n  }, {\n    key: \"drawEmptyPlus\",\n    value: function drawEmptyPlus(inRect) {\n      if (!this.book.isEmpty()) {\n        return;\n      }\n      var path1 = new _LinePath.default();\n      path1.moveTo(inRect.x, inRect.y + inRect.height() / 2);\n      path1.lineTo(inRect.x + inRect.width(), inRect.y + inRect.height() / 2);\n      var path2 = new _LinePath.default();\n      path2.moveTo(inRect.x + inRect.width() / 2, inRect.y);\n      path2.lineTo(inRect.x + inRect.width() / 2, inRect.y + inRect.height());\n      this.renderObj({\n        dom: null,\n        d: path1,\n        stroke: _Colors.default.getUiColor(0xC7C7C7),\n        strokeWidth: this.UiUtil.dip2px(5),\n        // fill: , \n        strokeLinecap: 'round'\n      });\n      this.renderObj({\n        dom: null,\n        d: path2,\n        stroke: _Colors.default.getUiColor(0xC7C7C7),\n        strokeWidth: this.UiUtil.dip2px(5),\n        // fill: , \n        strokeLinecap: 'round'\n      });\n    }\n  }, {\n    key: \"drawInterlayer\",\n    value: function drawInterlayer(inRect) {\n      //夹层\n      var path = new _LinePath.default();\n      var topLeft = new _CGPoint.default(inRect.x + this.horizontalOffset / 2, inRect.y);\n      var bottomLeft = new _CGPoint.default(topLeft.x + this.horizontalOffset, inRect.y + inRect.height());\n      var middleLeft = new _CGPoint.default(topLeft.x - this.horizontalOffset / 4, inRect.y + inRect.height() / 8 * 3);\n      var topRight = new _CGPoint.default(inRect.width() - this.horizontalOffset, inRect.y);\n      var bottomRight = new _CGPoint.default(inRect.width(), inRect.y + inRect.height());\n      var middleRight = new _CGPoint.default(topRight.x - this.horizontalOffset / 4, topRight.y + inRect.height() / 8 * 3);\n      var leftCircleCenter = this.Util.getCircleCenter(topLeft, middleLeft, bottomLeft);\n      var leftCircleRadius = this.Util.getPointSpacingByCGPoint(leftCircleCenter, bottomLeft);\n      var leftStartAngle = this.Util.getCircleDegreesInPoint(leftCircleCenter, bottomLeft);\n      var leftEndAngle = this.Util.getCircleDegreesInPoint(leftCircleCenter, topLeft);\n      var rightCircleCenter = this.Util.getCircleCenter(topRight, middleRight, bottomRight);\n      var rightCircleRadius = this.Util.getPointSpacingByCGPoint(rightCircleCenter, topRight);\n      var rightStartAngle = this.Util.getCircleDegreesInPoint(rightCircleCenter, topRight);\n      var rightEndAngle = this.Util.getCircleDegreesInPoint(rightCircleCenter, bottomRight);\n      path.moveTo(topLeft.x, topLeft.y);\n      path.lineTo(topRight.x, topRight.y);\n      path.circle(rightCircleRadius, rightCircleRadius, 0, 0, 0, bottomRight.x, bottomRight.y);\n      path.lineTo(bottomLeft.x, bottomLeft.y);\n      path.circle(leftCircleRadius, leftCircleRadius, 0, 0, 1, topLeft.x, topLeft.y);\n      var fill = 'rgba(0,0,0,0)'; //填充色\n      var stroke = 'rgba(0,0,0,0)'; //线条颜色\n      var pathStrokeWidth;\n      fill = _Colors.default.getUiColor(_Colors.default.black10);\n      pathStrokeWidth = 0;\n      this.renderObj({\n        dom: null,\n        d: path,\n        stroke: stroke,\n        strokeWidth: pathStrokeWidth,\n        fill: fill,\n        strokeLinecap: 'round'\n      });\n    }\n  }, {\n    key: \"drawRect\",\n    value: function drawRect(inRect, strokeColor, strokeWidth, fullColor, cornerRadius) {\n      var path = new _LinePath.default();\n      var x = inRect.x;\n      var y = inRect.y;\n      var width = inRect.width();\n      var height = inRect.height();\n      path.moveTo(x + cornerRadius, y);\n      path.lineTo(x + width - cornerRadius, y);\n      path.circle(cornerRadius, cornerRadius, 0, 0, 1, x + width, y + cornerRadius);\n      path.lineTo(x + width, y + height - cornerRadius);\n      path.circle(cornerRadius, cornerRadius, 0, 0, 1, x + width - cornerRadius, y + height - cornerRadius);\n      path.lineTo(x + cornerRadius, y + height);\n      path.circle(cornerRadius, cornerRadius, 0, 0, 1, x, y + height - cornerRadius);\n      path.lineTo(x, y + cornerRadius);\n      path.circle(cornerRadius, cornerRadius, 0, 0, 1, x + cornerRadius, y);\n      var fill = 'rgba(0,0,0,0)'; //填充色\n      var stroke = 'rgba(0,0,0,0)'; //线条颜色\n      var pathStrokeWidth;\n      if (!new _Strings.default().isEmpty(fullColor)) {\n        fill = fullColor;\n        pathStrokeWidth = 0;\n      }\n      if (strokeWidth > 0 && !new _Strings.default().isEmpty(strokeColor)) {\n        pathStrokeWidth = strokeWidth;\n        stroke = strokeColor;\n      }\n      this.renderObj({\n        dom: null,\n        d: path,\n        stroke: stroke,\n        strokeWidth: pathStrokeWidth,\n        fill: fill,\n        strokeLinecap: 'round'\n      });\n    }\n  }, {\n    key: \"drawFrontRect\",\n    value: function drawFrontRect(inRect, strokeColor, strokeWidth, fullColor, cornerRadius) {\n      var path = new _LinePath.default();\n      var x = inRect.x;\n      var y = inRect.y;\n      var width = inRect.width();\n      var height = inRect.height();\n      path.moveTo(x, y);\n      path.lineTo(x + width - cornerRadius, y);\n      path.circle(cornerRadius, cornerRadius, 0, 0, 1, x + width, y + cornerRadius);\n      path.lineTo(x + width, y + height - cornerRadius);\n      path.circle(cornerRadius, cornerRadius, 0, 0, 1, x + width - cornerRadius, y + height);\n      path.lineTo(x, y + height);\n      path.lineTo(x, y);\n      var fill = 'rgba(0,0,0,0)'; //填充色\n      var stroke = 'rgba(0,0,0,0)'; //线条颜色\n      var pathStrokeWidth;\n      if (!new _Strings.default().isEmpty(fullColor)) {\n        fill = fullColor;\n        pathStrokeWidth = 0;\n      }\n      if (strokeWidth > 0 && !new _Strings.default().isEmpty(strokeColor)) {\n        pathStrokeWidth = strokeWidth;\n        stroke = strokeColor;\n      }\n      this.renderObj({\n        dom: null,\n        d: path,\n        stroke: stroke,\n        strokeWidth: pathStrokeWidth,\n        fill: fill,\n        strokeLinecap: 'round'\n      });\n    }\n\n    //画底部白色的曲线图形。\n  }, {\n    key: \"drawFrontBottomRect\",\n    value: function drawFrontBottomRect(inRect, strokeColor, strokeWidth, fullColor, cornerRadius) {\n      var path = new _LinePath.default();\n      var x = inRect.x;\n      var y = inRect.y;\n      var width = inRect.width();\n      var height = inRect.height();\n      var circleHeight = width / 7;\n      var topLeft = new _CGPoint.default(inRect.x, inRect.y + circleHeight);\n      var topRight = new _CGPoint.default(inRect.x + inRect.width(), inRect.y + circleHeight);\n      var middle = new _CGPoint.default(inRect.x + inRect.width() / 2, inRect.y + circleHeight);\n      var middleLeft = new _CGPoint.default(topLeft.x + inRect.width() / 4, inRect.y);\n      var middleRight = new _CGPoint.default(topLeft.x + inRect.width() / 4 * 3, inRect.y + circleHeight * 2);\n      var leftCircleCenter = this.Util.getCircleCenter(topLeft, middleLeft, middle); //这三个坐标分别是左边圆弧的最左边，左边圆弧与矩形中心点的坐标，中心点（x轴为封面宽度的一半）的坐标。\n      var leftCircleRadius = this.Util.getPointSpacingByCGPoint(leftCircleCenter, topLeft);\n      var leftStartAngle = this.Util.getCircleDegreesInPoint(leftCircleCenter, topLeft);\n      var leftEndAngle = this.Util.getCircleDegreesInPoint(leftCircleCenter, middle);\n      var rightCircleCenter = this.Util.getCircleCenter(middle, middleRight, topRight);\n      var rightCircleRadius = this.Util.getPointSpacingByCGPoint(rightCircleCenter, middle);\n      var rightStartAngle = this.Util.getCircleDegreesInPoint(rightCircleCenter, middle);\n      var rightEndAngle = this.Util.getCircleDegreesInPoint(rightCircleCenter, topRight);\n      path.moveTo(topLeft.x, topLeft.y);\n      path.circle(leftCircleRadius, leftCircleRadius, 0, 0, 1, middle.x, middle.y);\n      path.circle(rightCircleRadius, rightCircleRadius, 0, 0, 0, topRight.x, topRight.y);\n      path.lineTo(x + width, y + height - cornerRadius);\n      path.circle(cornerRadius, cornerRadius, 0, 0, 1, x + width - cornerRadius, y + height);\n      path.lineTo(x, y + height);\n      path.lineTo(topLeft.x, topLeft.y);\n      var fill = 'rgba(0,0,0,0)'; //填充色\n      var stroke = 'rgba(0,0,0,0)'; //线条颜色\n      var pathStrokeWidth;\n      if (!new _Strings.default().isEmpty(fullColor)) {\n        fill = fullColor;\n        pathStrokeWidth = 0;\n      }\n      if (strokeWidth > 0 && !new _Strings.default().isEmpty(strokeColor)) {\n        pathStrokeWidth = strokeWidth;\n        stroke = strokeColor;\n      }\n      this.renderObj({\n        dom: null,\n        d: path,\n        stroke: stroke,\n        strokeWidth: pathStrokeWidth,\n        fill: fill,\n        strokeLinecap: 'round'\n      });\n      var borderPath = new _LinePath.default();\n      borderPath.moveTo(topRight.x, topRight.y);\n      borderPath.lineTo(x + width, y + height - cornerRadius);\n      borderPath.circle(cornerRadius, cornerRadius, 0, 0, 1, x + width - cornerRadius, y + height);\n      borderPath.lineTo(x, y + height);\n      this.renderObj({\n        dom: null,\n        d: borderPath,\n        stroke: _Colors.default.getUiColor(_Colors.default.black35),\n        strokeWidth: 1,\n        fill: 'rgba(0,0,0,0)',\n        strokeLinecap: 'round'\n      });\n    }\n  }, {\n    key: \"renderObj\",\n    value: function renderObj() {\n      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        dom: dom,\n        d: d,\n        stroke: stroke,\n        strokeWidth: strokeWidth,\n        strokeLinecap: strokeLinecap\n      };\n      //设置path\n      if (obj.dom == null) {\n        obj.dom = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n        this.gTag.appendChild(obj.dom);\n      }\n      if (obj.d != null) {\n        obj.dom.setAttribute(\"d\", obj.d.getLine());\n      }\n      if (obj.stroke != null) {\n        obj.dom.setAttribute(\"stroke\", obj.stroke);\n      }\n      if (obj.strokeWidth != null) {\n        obj.dom.setAttribute(\"stroke-width\", obj.strokeWidth);\n      }\n      if (obj.fill != null) {\n        obj.dom.setAttribute(\"fill\", obj.fill);\n      }\n      if (obj.strokeLinecap != null) {\n        obj.dom.setAttribute(\"stroke-linecap\", obj.strokeLinecap);\n      }\n    }\n  }, {\n    key: \"drawTitleAndTime\",\n    value: function drawTitleAndTime(frontRect, frontBottomRect) {\n      if (this.Strings.isEmpty(this.book.name)) {\n        return;\n      }\n      var textFontSize = 14;\n      var textColor = _Colors.default.isDarkColor(this.book.color) ? _Colors.default.white : _Colors.default.black55;\n      var title = this.Strings.lineFeed(this.book.name);\n      var titleSpace = this.UiUtil.dip2px(2);\n      var titleMaxWidth = this.book.width - this.frontLeft - titleSpace * 2;\n      var textSize = _MindElementCalculation.default.caluleText(title, textFontSize, true, titleMaxWidth);\n      var titleWidth = textSize.getWidth();\n      var titleHeight = textSize.getHeight();\n      //两行的高度\n      var towLineHeight = _MindElementCalculation.default.caluleText('1234', textFontSize, true, textFontSize * 2, textFontSize + 2).getHeight();\n      if (titleHeight > towLineHeight) {\n        titleHeight = towLineHeight;\n      }\n      var centerY = (frontBottomRect.y - frontRect.y) / 2;\n      var titleY = frontRect.y + centerY - titleHeight / 2;\n      var titleX = frontRect.x + titleSpace + (titleMaxWidth - titleWidth) / 2;\n      var obj = {\n        innerText: title,\n        x: titleX,\n        y: titleY,\n        width: parseInt(titleWidth),\n        height: parseInt(titleHeight),\n        color: _Colors.default.getUiColor(textColor),\n        fontSize: textFontSize,\n        lineHeight: textFontSize * _Config.default.textLineHeight,\n        textAlign: 'center'\n      };\n      this.createdText(obj);\n      textFontSize = 10;\n      // String time = Util.getTimeFormatYearMonthDayByPointConnection(book.time);\n      var time = _timestampToTime.default.timestampToTimeSeparator(parseInt(this.book.time / 1000), '.');\n      textSize = _MindElementCalculation.default.caluleText(time, textFontSize, false);\n      var timeWidth = textSize.getWidth();\n      var timeHeight = textSize.getHeight();\n      var timeX = this.book.width - textSize.getWidth() - this.margin + 2;\n      var timeY = this.book.height - textSize.getHeight() - this.margin + 2;\n      var timeObj = {\n        innerText: time,\n        x: timeX,\n        y: timeY,\n        width: parseInt(timeWidth),\n        height: parseInt(timeHeight),\n        color: _Colors.default.getUiColor(_Colors.default.black50),\n        fontSize: this.UiUtil.dip2px(textFontSize),\n        lineHeight: this.UiUtil.dip2px(textFontSize) * _Config.default.textLineHeight,\n        textAlign: 'center'\n      };\n      this.createdText(timeObj);\n    }\n  }, {\n    key: \"drawSheetNumber\",\n    value: function drawSheetNumber() {\n      if (this.book.sheetNumber <= 0) {\n        return;\n      }\n      var textFontSize = 12;\n      var title = this.book.sheetNumber + \"\";\n      var textSize = _MindElementCalculation.default.caluleText(title, textFontSize, true);\n      var titleWidth = textSize.getWidth();\n      var titleHeight = textSize.getHeight();\n      var titleSpace = this.UiUtil.dip2px(2);\n      var radius = Math.sqrt(Math.pow(titleWidth, 2) + Math.pow(titleHeight, 2)) / 2 + titleSpace;\n      var centralPointX = this.book.width - (this.book.width - this.frontLeft) / 4;\n      var centralPointY = this.frontBottomRectTop + radius;\n      var rect = new _Rect.default(centralPointX - radius, centralPointY - radius, radius * 2, radius * 2);\n      var textColor;\n      var backgroundColor;\n      if (_Colors.default.isDarkColor(this.book.color)) {\n        textColor = _Colors.default.getUiColor(this.book.color);\n        backgroundColor = _Colors.default.getUiColor(_Colors.default.white);\n      } else {\n        textColor = _Colors.default.getUiColor(_Colors.default.white);\n        backgroundColor = _Colors.default.getUiColor(_Colors.default.black60);\n      }\n      var titleX = rect.x + (rect.width() - titleWidth) / 2;\n      var titleY = rect.y + (rect.height() - titleHeight) / 2;\n      var path = new _LinePath.default();\n      path.moveTo(centralPointX - radius, centralPointY);\n      path.circle(radius, radius, 0, 0, 1, centralPointX + radius, centralPointY);\n      path.circle(radius, radius, 0, 0, 1, centralPointX - radius, centralPointY);\n      this.renderObj({\n        dom: null,\n        d: path,\n        stroke: null,\n        strokeWidth: null,\n        fill: backgroundColor,\n        strokeLinecap: 'round'\n      });\n      var obj = {\n        innerText: title,\n        x: titleX,\n        y: titleY,\n        width: parseInt(titleWidth),\n        height: parseInt(titleHeight),\n        color: textColor,\n        fontSize: textFontSize,\n        lineHeight: parseInt(titleHeight),\n        fontWeight: 700,\n        textAlign: 'center'\n      };\n      this.createdText(obj);\n    }\n  }, {\n    key: \"createdText\",\n    value: function createdText() {\n      var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        innerText: innerText,\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        color: color,\n        fontSize: fontSize,\n        lineHeight: lineHeight,\n        textAlign: textAlign,\n        divWidth: divWidth,\n        divHeight: divHeight\n      };\n      var foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');\n      this.gTag.appendChild(foreignObject);\n      foreignObject.setAttribute('x', obj.x);\n      foreignObject.setAttribute('y', obj.y);\n      foreignObject.setAttribute('width', obj.width);\n      foreignObject.setAttribute('height', obj.height);\n      var div = document.createElement('div');\n      foreignObject.appendChild(div);\n      if (obj.color != null) {\n        div.style.color = obj.color;\n      }\n      if (obj.fontSize != null) {\n        div.style.fontSize = obj.fontSize + 'px';\n      }\n      if (obj.lineHeight != null) {\n        div.style.lineHeight = obj.lineHeight + 'px';\n      }\n      if (obj.innerText != null) {\n        div.innerText = obj.innerText;\n      }\n      if (obj.textAlign != null) {\n        div.style.textAlign = 'center';\n      }\n      if (obj.fontWeight != null) {\n        div.style.fontWeight = obj.fontWeight;\n      }\n      if (obj.divHeight != null) {\n        div.style.height = obj.divHeight + 'px';\n      }\n      if (obj.divWidth != null) {\n        div.style.width = obj.divWidth + 'px';\n      }\n      if (obj.borderRadius != null) {\n        div.style.borderRadius = obj.borderRadius;\n      }\n      if (obj.backgroundImage != null) {\n        div.style.backgroundImage = 'url(' + obj.backgroundImage + ')';\n      }\n      if (obj.backgroundSize != null) {\n        div.style.backgroundSize = 'cover';\n      }\n      if (obj.backgroundPosition != null) {\n        div.style.backgroundPosition = 'center center';\n      }\n      if (obj.backgroundRepeat != null) {\n        div.style.backgroundRepeat = 'no-repeat';\n      }\n\n      // 默认的单词换行\n      if (obj.wordBreak == null) {\n        div.style.wordBreak = \"break-word\";\n      }\n      //默认的文字间距\n      if (obj.whiteSpace == null) {\n        div.style.whiteSpace = \"pre-wrap\";\n      }\n    }\n  }, {\n    key: \"drawImage\",\n    value: function drawImage() {\n      var width = this.book.width / 3;\n      var height = width;\n      var imageX = this.edgeHieght + this.horizontalOffset / 2 * 3 + (this.book.width - this.horizontalOffset) / 4 - width / 2;\n      var imageY = this.frontBottomRectTop + this.margin;\n      var url = (0, _httpImageToPrefix.default)(this.book.url);\n      // let url = httpImageToPrefix('http://192.168.3.4:12300/r/mindmap/image/72900214a810de192fc4a4d9e6b483c5.png');\n      var obj = {\n        x: imageX,\n        y: imageY,\n        width: parseInt(width),\n        height: parseInt(height),\n        divWidth: parseInt(width),\n        divHeight: parseInt(height),\n        backgroundImage: url,\n        borderRadius: '50%',\n        backgroundSize: 'cover',\n        backgroundPosition: 'center center',\n        backgroundRepeat: 'no-repeat'\n      };\n      this.createdText(obj);\n    }\n  }]);\n  return BookView;\n}();\nvar _default = exports.default = BookView;\n\n//# sourceURL=webpack:///./src/views/book/ui/BookView.js?");

/***/ })

}]);